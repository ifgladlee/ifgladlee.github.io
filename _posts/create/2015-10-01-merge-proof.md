---
layout: post
title: "归并排序中归并操作中临时数组空间节省问题"
categories: diary
---

在CLRS（《算法导论》）一书中，归并排序的归并操作伪代码里，为了备份左右两个已排好序的数组以防止在归并操作中将原始数据覆盖，开辟了两个数组，空间长度为n。

而在邓俊辉《数据结构（C++语言版）》中，归并操作里只开辟了一个临时数组，只用来备份左半部分已排好序的数组，右半边的数组就地进行操作，难道他不担心在归并操作中右半部分的原始数据被赋值给覆盖了么？下面就简单给出一种证明，说明这种担心是多余的。

记左半部分数组（备份后的）为*A*,右半部分数组为*B*，设其长度分别为*n1*和*n2*，（事实上对于归并排序，要么*n1*== *n2*要么*n1* == *n2*+1）。

在归并操作中，从将原数组从左至右进行赋值。我们考虑当赋值操作在左半部分刚好完成这个时候，在此之前，右半部分即*B*数组都未受到影响，此时一共完成了*n1*个赋值操作。记这*n1*个数里面，有*a*个数来自于数组*A*，有*n1-a*个数来自于数组*B*。也就是说，数组*A*还剩下*n1-a*个数未归并，而*B*数组还剩下*n2-n1+a*个数未归并。

关键就在于，数组*A*中还有*n1-a*个未归并，而数组*B*中已经有*n1-a*个数已经归并。

那么在接下来的归并操作中，右半部分的数组也会被一一重新赋值。我们考虑右半部分的前*n1-a*这一段，这一段对于数组*B*而言已经不重要，因为它已经被归并，被覆盖与否都无所谓了。所以右半部分至少有*n1-a*个安全的位置，而数组*A*中还剩下需要归并的数一共也刚好是*n1-a*个，所以在极端情况下，*A*中剩下的所有值都被赋值到右半部分，也全部会落入安全位置中，剩下的就是*B*数组，自己覆盖自己一遍没有任何影响。

所以，在归并操作中，只备份左半部分的数组就能够保证其安全性了。
